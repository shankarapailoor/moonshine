package distiller

import (
	"fmt"
	"github.com/google/syzkaller/prog"
	"math"
	"math/rand"
	"os"
	"time"
)

type RandomDistiller struct {
	*Metadata
}

// Number of calls generated by distilling LTP + Kself + Posix + Glibc
const NumCallsLTPKselfPosixGlibc = 16442

// Number of calls generated by distilling LTP + Kself + Posix
const NumCallsLTPKselfPosix = 15333

// Number of calls generated by distilling LTP + Kself
const NumCallsLTPKself = 12712

func (d *RandomDistiller) getHeavyHitters(seeds Seeds) map[*Seed]int {
	seenIps := make(map[uint64]bool)
	heavyHitters := make(map[*Seed]int)
	for i, seed := range seeds {
		ips := d.contributes(seed, seenIps) /* how many unique Ips does seed contribute */
		if ips > 0 {
			heavyHitters[seed] = i
			fmt.Printf("Seed: %s contributes: %d ips out of its total of: %d\n", seed.Call.Meta.Name, ips, len(seed.Cover))
		}
	}
	return heavyHitters
}

func (d *RandomDistiller) getRandomCallIndices(seeds Seeds, N int, total int) map[int][]int {
	randIndices := make(map[int][]int)
	r := rand.New(rand.NewSource(time.Now().Unix()))
	perm := r.Perm(seeds.Len())
	total = int(math.Min(float64(total), float64(len(seeds))))
	callsPerBucket := (total - N) / N

	fmt.Fprintf(os.Stderr, "perm of length %d\n", len(perm))

	for i := 0; i < N; i++ {
		randIndices[i] = perm[(i * callsPerBucket):((i + 1) * callsPerBucket)]
	}

	return randIndices
}

func (d *RandomDistiller) Add(seeds Seeds) {
	d.Seeds = seeds
	for _, seed := range seeds {
		d.CallToSeed[seed.Call] = seed
		d.UpstreamDependencyGraph[seed] = make(map[int]map[prog.Arg][]prog.Arg, 0)
		seed.ArgMeta = make(map[prog.Arg]bool, 0)
		for call, idx := range seed.DependsOn {
			if _, ok := d.UpstreamDependencyGraph[seed][idx]; !ok {
				d.UpstreamDependencyGraph[seed][idx] = make(map[prog.Arg][]prog.Arg, 0)
			}
			d.CallToIdx[call] = idx
		}
		d.CallToIdx[seed.Call] = seed.CallIdx
	}
}

func (d *RandomDistiller) Distill(progs []*prog.Prog) (distilled []*prog.Prog) {
	fmt.Fprintf(os.Stderr, "Distilling %d programs with Random Distillation\n", len(progs))
	seeds := d.Seeds
	heavyHitters := d.getHeavyHitters(seeds)
	N := len(heavyHitters)
	fmt.Fprintf(os.Stderr, "Generating random progs around %d heavy hitters and %d seeds\n", N, len(seeds))
	// change this to test different corpuses
	// totalRandCalls :=  NumCallsLTPKselfPosixGlibc
	totalRandCalls := NumCallsLTPKself
	seedsWithoutHeavy := make(Seeds, 0)
	for _, seed := range seeds {
		if _, ok := heavyHitters[seed]; !ok {
			seedsWithoutHeavy = append(seedsWithoutHeavy, seed)
		}
	}
	if len(seedsWithoutHeavy) != (seeds.Len() - N) {
		panic("Did not properly remove heavy hitters from random seeds")
	}
	randIndices := d.getRandomCallIndices(seedsWithoutHeavy, N, totalRandCalls)
	i := 0
	totalAddedCalls := 0
	for heavyHitter, _ := range heavyHitters {
		randProg := new(prog.Prog)
		randProg.Calls = make([]*prog.Call, 0)
		for _, j := range randIndices[i] {
			totalAddedCalls = totalAddedCalls + 1
			randProg.Calls = append(randProg.Calls, seeds[j].Call)
		}
		randProg.Calls = append(randProg.Calls, heavyHitter.Call)
		totalAddedCalls = totalAddedCalls + 1
		distilled = append(distilled, randProg)
		i++
	}
	distilled = d.StripDependencies(distilled)
	fmt.Fprintf(os.Stderr, "Collected %d random calls in %d programs", totalAddedCalls, len(distilled))
	return distilled
}

func (d *RandomDistiller) StripDependencies(distilledProgs []*prog.Prog) []*prog.Prog {
	for _, p := range distilledProgs {
		p.StripDependencies()
	}
	return distilledProgs
}
